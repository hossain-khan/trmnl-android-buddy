package ink.trmnl.android.buddy.dev

import android.content.Context
import androidx.compose.runtime.CompositionLocalProvider
import androidx.compose.ui.platform.LocalContext
import androidx.test.core.app.ApplicationProvider
import androidx.work.WorkInfo
import assertk.assertThat
import assertk.assertions.hasSize
import assertk.assertions.isEmpty
import assertk.assertions.isEqualTo
import assertk.assertions.isFalse
import assertk.assertions.isNotNull
import assertk.assertions.isTrue
import com.slack.circuit.test.FakeNavigator
import com.slack.circuit.test.test
import ink.trmnl.android.buddy.work.WorkManagerObserver
import ink.trmnl.android.buddy.work.WorkerStatus
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.test.runTest
import org.junit.Test
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner

/**
 * Unit tests for DevelopmentPresenter.
 *
 * Tests cover:
 * - Initial state loading
 * - Worker status observation
 * - Notification test events
 * - Worker trigger events
 * - Worker management (cancel all, reset schedules)
 * - Navigation events
 * - Permission state handling
 *
 * Uses Robolectric to provide Android Context for Compose testing.
 */
@RunWith(RobolectricTestRunner::class)
class DevelopmentPresenterTest {
    private val context: Context = ApplicationProvider.getApplicationContext()

    @Test
    fun `presenter loads with initial state`() =
        runTest {
            // Given
            val navigator = FakeNavigator(DevelopmentScreen)
            val workManagerObserver = FakeWorkManagerObserver()
            val presenter = DevelopmentPresenter(navigator, workManagerObserver)

            // When/Then
            CompositionLocalProvider(LocalContext provides context) {
                presenter.test {
                    val initialState = awaitItem()

                    assertThat(initialState.notificationPermissionGranted).isTrue() // Default on older Android
                    assertThat(initialState.workerStatuses).isEmpty()
                }
            }
        }

    @Test
    fun `presenter observes worker statuses`() =
        runTest {
            // Given
            val navigator = FakeNavigator(DevelopmentScreen)
            val workManagerObserver = FakeWorkManagerObserver()
            val presenter = DevelopmentPresenter(navigator, workManagerObserver)

            // When/Then
            CompositionLocalProvider(LocalContext provides context) {
                presenter.test {
                    var state = awaitItem()
                    assertThat(state.workerStatuses).isEmpty()

                    // Update worker statuses
                    workManagerObserver.updateWorkerStatuses(
                        listOf(
                            WorkerStatus(
                                name = "battery_collection",
                                displayName = "Battery Collection",
                                state = WorkInfo.State.SUCCEEDED,
                                runAttemptCount = 1,
                                tags = setOf("periodic"),
                            ),
                            WorkerStatus(
                                name = "low_battery_notification",
                                displayName = "Low Battery Notification",
                                state = WorkInfo.State.ENQUEUED,
                                runAttemptCount = 0,
                                tags = setOf("periodic"),
                            ),
                        ),
                    )

                    state = awaitItem()
                    assertThat(state.workerStatuses).hasSize(2)
                    assertThat(state.workerStatuses[0].state).isEqualTo(WorkInfo.State.SUCCEEDED)
                    assertThat(state.workerStatuses[1].state).isEqualTo(WorkInfo.State.ENQUEUED)
                }
            }
        }

    @Test
    fun `test low battery notification event is handled`() =
        runTest {
            // Given
            val navigator = FakeNavigator(DevelopmentScreen)
            val workManagerObserver = FakeWorkManagerObserver()
            val presenter = DevelopmentPresenter(navigator, workManagerObserver)

            // When/Then
            presenter.test {
                val state = awaitItem()

                // Trigger test notification - event is handled but we can't verify Context interactions
                state.eventSink(DevelopmentScreen.Event.TestLowBatteryNotification(deviceCount = 2, thresholdPercent = 15))

                // State should not change, but event should be processed
                // The presenter handles the event internally, no state update expected
                cancelAndIgnoreRemainingEvents()
            }
        }

    @Test
    fun `test blog post notification event is handled`() =
        runTest {
            // Given
            val navigator = FakeNavigator(DevelopmentScreen)
            val workManagerObserver = FakeWorkManagerObserver()
            val presenter = DevelopmentPresenter(navigator, workManagerObserver)

            // When/Then
            presenter.test {
                val state = awaitItem()

                // Trigger test notification
                state.eventSink(DevelopmentScreen.Event.TestBlogPostNotification(postCount = 3))

                // Event is handled but doesn't change state
                cancelAndIgnoreRemainingEvents()
            }
        }

    @Test
    fun `test announcement notification event is handled`() =
        runTest {
            // Given
            val navigator = FakeNavigator(DevelopmentScreen)
            val workManagerObserver = FakeWorkManagerObserver()
            val presenter = DevelopmentPresenter(navigator, workManagerObserver)

            // When/Then
            presenter.test {
                val state = awaitItem()

                // Trigger test notification
                state.eventSink(DevelopmentScreen.Event.TestAnnouncementNotification(announcementCount = 1))

                // Event is handled but doesn't change state
                cancelAndIgnoreRemainingEvents()
            }
        }

    @Test
    fun `trigger low battery worker event is handled`() =
        runTest {
            // Given
            val navigator = FakeNavigator(DevelopmentScreen)
            val workManagerObserver = FakeWorkManagerObserver()
            val presenter = DevelopmentPresenter(navigator, workManagerObserver)

            // When/Then
            presenter.test {
                val state = awaitItem()

                // Trigger worker - event is handled but requires Context (not testable without integration)
                state.eventSink(DevelopmentScreen.Event.TriggerLowBatteryWorker)

                // Event is handled but doesn't change state
                cancelAndIgnoreRemainingEvents()
            }
        }

    @Test
    fun `trigger blog post worker event is handled`() =
        runTest {
            // Given
            val navigator = FakeNavigator(DevelopmentScreen)
            val workManagerObserver = FakeWorkManagerObserver()
            val presenter = DevelopmentPresenter(navigator, workManagerObserver)

            // When/Then
            presenter.test {
                val state = awaitItem()

                state.eventSink(DevelopmentScreen.Event.TriggerBlogPostWorker)

                cancelAndIgnoreRemainingEvents()
            }
        }

    @Test
    fun `trigger announcement worker event is handled`() =
        runTest {
            // Given
            val navigator = FakeNavigator(DevelopmentScreen)
            val workManagerObserver = FakeWorkManagerObserver()
            val presenter = DevelopmentPresenter(navigator, workManagerObserver)

            // When/Then
            presenter.test {
                val state = awaitItem()

                state.eventSink(DevelopmentScreen.Event.TriggerAnnouncementWorker)

                cancelAndIgnoreRemainingEvents()
            }
        }

    @Test
    fun `trigger battery collection worker event is handled`() =
        runTest {
            // Given
            val navigator = FakeNavigator(DevelopmentScreen)
            val workManagerObserver = FakeWorkManagerObserver()
            val presenter = DevelopmentPresenter(navigator, workManagerObserver)

            // When/Then
            presenter.test {
                val state = awaitItem()

                state.eventSink(DevelopmentScreen.Event.TriggerBatteryCollectionWorker)

                cancelAndIgnoreRemainingEvents()
            }
        }

    @Test
    fun `cancel all workers event calls WorkManagerObserver`() =
        runTest {
            // Given
            val navigator = FakeNavigator(DevelopmentScreen)
            val workManagerObserver = FakeWorkManagerObserver()
            val presenter = DevelopmentPresenter(navigator, workManagerObserver)

            // When/Then
            presenter.test {
                val state = awaitItem()

                assertThat(workManagerObserver.cancelAllWorkersCalled).isFalse()

                state.eventSink(DevelopmentScreen.Event.CancelAllWorkers)

                // Give time for coroutine to execute
                kotlinx.coroutines.delay(100)

                assertThat(workManagerObserver.cancelAllWorkersCalled).isTrue()

                cancelAndIgnoreRemainingEvents()
            }
        }

    @Test
    fun `reset worker schedules event calls WorkManagerObserver`() =
        runTest {
            // Given
            val navigator = FakeNavigator(DevelopmentScreen)
            val workManagerObserver = FakeWorkManagerObserver()
            val presenter = DevelopmentPresenter(navigator, workManagerObserver)

            // When/Then
            presenter.test {
                val state = awaitItem()

                assertThat(workManagerObserver.resetWorkerSchedulesCalled).isFalse()

                state.eventSink(DevelopmentScreen.Event.ResetWorkerSchedules)

                // Give time for coroutine to execute
                kotlinx.coroutines.delay(100)

                assertThat(workManagerObserver.resetWorkerSchedulesCalled).isTrue()

                cancelAndIgnoreRemainingEvents()
            }
        }

    @Test
    fun `request notification permission event is handled`() =
        runTest {
            // Given
            val navigator = FakeNavigator(DevelopmentScreen)
            val workManagerObserver = FakeWorkManagerObserver()
            val presenter = DevelopmentPresenter(navigator, workManagerObserver)

            // When/Then
            presenter.test {
                val state = awaitItem()

                // Request permission - event is handled but permission state is managed by Accompanist
                state.eventSink(DevelopmentScreen.Event.RequestNotificationPermission)

                // Event is handled but doesn't change state
                cancelAndIgnoreRemainingEvents()
            }
        }

    @Test
    fun `open notification settings event is handled`() =
        runTest {
            // Given
            val navigator = FakeNavigator(DevelopmentScreen)
            val workManagerObserver = FakeWorkManagerObserver()
            val presenter = DevelopmentPresenter(navigator, workManagerObserver)

            // When/Then
            presenter.test {
                val state = awaitItem()

                // Open settings - event is handled but requires Context (not testable without integration)
                state.eventSink(DevelopmentScreen.Event.OpenNotificationSettings)

                // Event is handled but doesn't change state
                cancelAndIgnoreRemainingEvents()
            }
        }

    @Test
    fun `navigate back event calls navigator pop`() =
        runTest {
            // Given
            val navigator = FakeNavigator(DevelopmentScreen)
            val workManagerObserver = FakeWorkManagerObserver()
            val presenter = DevelopmentPresenter(navigator, workManagerObserver)

            // When/Then
            presenter.test {
                val state = awaitItem()

                state.eventSink(DevelopmentScreen.Event.NavigateBack)

                // Verify navigation occurred
                assertThat(navigator.awaitPop()).isNotNull()

                cancelAndIgnoreRemainingEvents()
            }
        }

    @Test
    fun `multiple worker status updates are reflected in state`() =
        runTest {
            // Given
            val navigator = FakeNavigator(DevelopmentScreen)
            val workManagerObserver = FakeWorkManagerObserver()
            val presenter = DevelopmentPresenter(navigator, workManagerObserver)

            // When/Then
            presenter.test {
                var state = awaitItem()
                assertThat(state.workerStatuses).isEmpty()

                // First update - add battery worker
                workManagerObserver.updateWorkerStatuses(
                    listOf(
                        WorkerStatus(
                            name = "battery_collection",
                            displayName = "Battery Collection",
                            state = WorkInfo.State.RUNNING,
                            runAttemptCount = 1,
                            tags = setOf("periodic"),
                        ),
                    ),
                )

                state = awaitItem()
                assertThat(state.workerStatuses).hasSize(1)
                assertThat(state.workerStatuses[0].state).isEqualTo(WorkInfo.State.RUNNING)

                // Second update - add more workers
                workManagerObserver.updateWorkerStatuses(
                    listOf(
                        WorkerStatus(
                            name = "battery_collection",
                            displayName = "Battery Collection",
                            state = WorkInfo.State.SUCCEEDED,
                            runAttemptCount = 1,
                            tags = setOf("periodic"),
                        ),
                        WorkerStatus(
                            name = "low_battery_notification",
                            displayName = "Low Battery Notification",
                            state = WorkInfo.State.ENQUEUED,
                            runAttemptCount = 0,
                            tags = setOf("periodic"),
                        ),
                        WorkerStatus(
                            name = "blog_post_sync",
                            displayName = "Blog Post Sync",
                            state = WorkInfo.State.RUNNING,
                            runAttemptCount = 2,
                            tags = setOf("periodic"),
                        ),
                    ),
                )

                state = awaitItem()
                assertThat(state.workerStatuses).hasSize(3)
                assertThat(state.workerStatuses[0].state).isEqualTo(WorkInfo.State.SUCCEEDED)
                assertThat(state.workerStatuses[1].state).isEqualTo(WorkInfo.State.ENQUEUED)
                assertThat(state.workerStatuses[2].state).isEqualTo(WorkInfo.State.RUNNING)
            }
        }

    @Test
    fun `worker status with failed state is displayed correctly`() =
        runTest {
            // Given
            val navigator = FakeNavigator(DevelopmentScreen)
            val workManagerObserver = FakeWorkManagerObserver()
            val presenter = DevelopmentPresenter(navigator, workManagerObserver)

            // When/Then
            presenter.test {
                var state = awaitItem()

                // Add failed worker
                workManagerObserver.updateWorkerStatuses(
                    listOf(
                        WorkerStatus(
                            name = "battery_collection",
                            displayName = "Battery Collection",
                            state = WorkInfo.State.FAILED,
                            runAttemptCount = 3,
                            tags = setOf("periodic"),
                        ),
                    ),
                )

                state = awaitItem()
                assertThat(state.workerStatuses).hasSize(1)
                assertThat(state.workerStatuses[0].state).isEqualTo(WorkInfo.State.FAILED)
                assertThat(state.workerStatuses[0].runAttemptCount).isEqualTo(3)
            }
        }

    @Test
    fun `worker status with cancelled state is displayed correctly`() =
        runTest {
            // Given
            val navigator = FakeNavigator(DevelopmentScreen)
            val workManagerObserver = FakeWorkManagerObserver()
            val presenter = DevelopmentPresenter(navigator, workManagerObserver)

            // When/Then
            presenter.test {
                var state = awaitItem()

                // Add cancelled worker
                workManagerObserver.updateWorkerStatuses(
                    listOf(
                        WorkerStatus(
                            name = "announcement_sync",
                            displayName = "Announcement Sync",
                            state = WorkInfo.State.CANCELLED,
                            runAttemptCount = 1,
                            tags = setOf("periodic"),
                        ),
                    ),
                )

                state = awaitItem()
                assertThat(state.workerStatuses).hasSize(1)
                assertThat(state.workerStatuses[0].state).isEqualTo(WorkInfo.State.CANCELLED)
            }
        }

    @Test
    fun `empty worker statuses are handled correctly`() =
        runTest {
            // Given
            val navigator = FakeNavigator(DevelopmentScreen)
            val workManagerObserver = FakeWorkManagerObserver()
            val presenter = DevelopmentPresenter(navigator, workManagerObserver)

            // When/Then
            presenter.test {
                var state = awaitItem()
                assertThat(state.workerStatuses).isEmpty()

                // Add workers
                workManagerObserver.updateWorkerStatuses(
                    listOf(
                        WorkerStatus(
                            name = "battery_collection",
                            displayName = "Battery Collection",
                            state = WorkInfo.State.RUNNING,
                            runAttemptCount = 1,
                            tags = setOf("periodic"),
                        ),
                    ),
                )

                state = awaitItem()
                assertThat(state.workerStatuses).hasSize(1)

                // Clear workers
                workManagerObserver.updateWorkerStatuses(emptyList())

                state = awaitItem()
                assertThat(state.workerStatuses).isEmpty()
            }
        }
}

/**
 * Fake implementation of WorkManagerObserver for testing.
 * Avoids mocking per project guidelines.
 */
private class FakeWorkManagerObserver : WorkManagerObserver {
    private val _workerStatusesFlow = MutableStateFlow<List<WorkerStatus>>(emptyList())

    var cancelAllWorkersCalled = false
        private set

    var resetWorkerSchedulesCalled = false
        private set

    override fun observeAllWorkers(): Flow<List<WorkerStatus>> = _workerStatusesFlow

    override fun cancelAllWorkers() {
        cancelAllWorkersCalled = true
    }

    override fun resetAllWorkerSchedules() {
        resetWorkerSchedulesCalled = true
    }

    /**
     * Helper method to update worker statuses for testing.
     */
    fun updateWorkerStatuses(statuses: List<WorkerStatus>) {
        _workerStatusesFlow.value = statuses
    }
}
